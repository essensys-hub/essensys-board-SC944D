{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentation Module SC944D","text":"<p>Bienvenue dans la documentation technique du module SC944D pour le projet Open Source Essensys.</p> <p>Ce module est une carte \u00e9lectronique con\u00e7ue pour [Ins\u00e9rer description br\u00e8ve si connue, ou laisser g\u00e9n\u00e9rique]. Cette documentation fournit tous les d\u00e9tails n\u00e9cessaires pour comprendre l'architecture, fabriquer le hardware et d\u00e9velopper le firmware.</p>"},{"location":"#apercu-du-schema","title":"Aper\u00e7u du sch\u00e9ma","text":"<p>Voici un aper\u00e7u des pages cl\u00e9s du sch\u00e9ma \u00e9lectronique :</p> <p> Microcontr\u00f4leur</p> <p> Connecteurs</p> <p>[!TIP] Le sch\u00e9ma complet est disponible en t\u00e9l\u00e9chargement ou dans la section Hardware.</p>"},{"location":"#sections","title":"Sections","text":"<ul> <li>\ud83c\udfdb\ufe0f Architecture : Vue d'ensemble du syst\u00e8me et diagrammes blocs.</li> <li>\ud83d\udd0c Hardware : D\u00e9tails \u00e9lectroniques, routage et composants.</li> <li>\ud83d\udcbe T\u00e9l\u00e9chargements : Fichiers sources, mod\u00e8les 3D et fichiers de fabrication.</li> <li>\ud83d\udcbb Firmware : Guide de d\u00e9veloppement et mapping m\u00e9moire.</li> </ul>"},{"location":"architecture/","title":"\ud83c\udfdb\ufe0f Architecture","text":""},{"location":"architecture/#vue-densemble","title":"Vue d'ensemble","text":"<p>Le module SC944D s'int\u00e8gre dans l'\u00e9cosyst\u00e8me Essensys en tant que [R\u00f4le du module].</p>"},{"location":"architecture/#diagramme-bloc","title":"Diagramme Bloc","text":"<p>[Ins\u00e9rer diagramme ici]</p>"},{"location":"architecture/#interfaces","title":"Interfaces","text":"<ul> <li>Bus CAN : Communication avec le syst\u00e8me central.</li> <li>I/O : Entr\u00e9es/Sorties disponibles.</li> </ul>"},{"location":"downloads/","title":"\ud83d\udcbe T\u00e9l\u00e9chargements","text":"<p>Retrouvez ici tous les fichiers sources et de fabrication pour le module SC944D.</p> Type Fichier Description \ud83d\udcc1 Sch\u00e9ma SC944D_Schematic.pdf Sch\u00e9ma \u00e9lectronique complet au format PDF. \ud83d\udce6 Mod\u00e8le 3D SC944D.step Mod\u00e8le m\u00e9canique STEP pour l'int\u00e9gration 3D. \ud83c\udfed Fabrication SC944D_Gerbers.zip Fichiers Gerber et de per\u00e7age pour la fabrication du PCB. \ud83d\udd29 Assemblage SC944D_Assembly.pdf Plans d'assemblage des composants."},{"location":"firmware/","title":"\ud83d\udcbb Documentation Firmware","text":"<p>Le firmware du module SC944D est bas\u00e9 sur le RTOS MQX et tourne sur un microcontr\u00f4leur ColdFire MCF52259.</p>"},{"location":"firmware/#environnement-de-developpement","title":"Environnement de D\u00e9veloppement","text":"<ul> <li>IDE : CodeWarrior for ColdFire.</li> <li>OS : MQX RTOS.</li> <li>Langage : C.</li> </ul>"},{"location":"firmware/#structure-du-projet","title":"Structure du Projet","text":"<ul> <li><code>C/</code> : Sources (.c) dont <code>main.c</code>, <code>ba.c</code>, <code>Ethernet/www.c</code>.</li> <li><code>H/</code> : Headers (.h) dont <code>Hard.h</code>, <code>TableEchange.h</code>.</li> </ul>"},{"location":"firmware/#algorithmes-principaux","title":"Algorithmes Principaux","text":""},{"location":"firmware/#1-demarrage-du-client-mainc","title":"1. D\u00e9marrage du Client (<code>main.c</code>)","text":"<p>Au reset, la t\u00e2che Main_task ex\u00e9cute la s\u00e9quence suivante :</p> <ol> <li>Initialisation Hardware : Appel de <code>vd_InitHard()</code> (configuration des I/O, PWM, ADC).</li> <li>Lecture Configuration (EEPROM) :<ul> <li>Ouverture du port SPI (<code>vd_SpiOpen</code>).</li> <li>Lecture de l'adresse MAC.</li> <li>Lecture de la Cl\u00e9 Serveur (chiffr\u00e9e).</li> <li>Lecture du Code Alarme.</li> </ul> </li> <li>Initialisation Applicative :<ul> <li>Initialisation des modules : Chauffage (<code>vd_Chauffage</code>), Alarme (<code>vd_AlarmeInit</code>), Timers.</li> </ul> </li> <li>D\u00e9marrage des T\u00e2ches :<ul> <li><code>vd_StartTacheEcran()</code> : IHM locale.</li> <li><code>vd_StartTacheBA()</code> : Communication I2C avec les cartes filles.</li> <li><code>vd_StartTacheTeleinfo()</code> : Lecture compteur Linky.</li> <li><code>vd_StartTacheEthernet()</code> : Connexion serveur.</li> </ul> </li> <li>Boucle Principale : Surveillance alimentation et batterie (Watchdog soft).</li> </ol>"},{"location":"firmware/#2-communication-inter-board-sc940-sc941-etc","title":"2. Communication Inter-Board (SC940, SC941, etc.)","text":"<p>Le SC944D agit comme Ma\u00eetre I2C vis-\u00e0-vis des modules auxiliaires (BA). Cette gestion est assur\u00e9e par la t\u00e2che <code>Boitiers_task</code> (<code>C/ba.c</code>) et le driver <code>C/ba_i2c.c</code>.</p>"},{"location":"firmware/#details-de-la-commande-uc_trame_ba_actions","title":"D\u00e9tails de la commande <code>uc_TRAME_BA_ACTIONS</code>","text":"<p>La commande <code>uc_TRAME_BA_ACTIONS</code> est le c\u0153ur de la synchronisation entre le module principal (SC944D) et les esclaves (SC940/1/2/3).</p> <ul> <li> <p>Fr\u00e9quence d'ex\u00e9cution :</p> <ul> <li>La t\u00e2che <code>BA_TASK</code> tourne en boucle infinie (<code>for(;;)</code>).</li> <li>Elle est ordonnanc\u00e9e par le RTOS MQX avec une priorit\u00e9 de 8 et un Time Slice de 50ms.</li> <li>Concr\u00e8tement, la t\u00e2che balaie en permanence tous les bo\u00eetiers auxiliaires d\u00e9clar\u00e9s. D\u00e8s qu'un changement est d\u00e9tect\u00e9 entre l'\u00e9tat demand\u00e9 (consigne) et l'\u00e9tat connu, la trame est envoy\u00e9e. Si aucune action n'est requise, la boucle continue de v\u00e9rifier les \u00e9tats.</li> <li>Note : C'est donc un processus \"temps r\u00e9el\" quasi-imm\u00e9diat (limit\u00e9 par la vitesse du bus I2C et le temps CPU).</li> </ul> </li> <li> <p>R\u00e9cup\u00e9ration d'\u00e9tat (Status) :</p> <ul> <li>La communication I2C utilise un m\u00e9canisme de Repeated Start.</li> <li>Le cycle est : <code>WRITE (Commande + Data)</code> -&gt; <code>RESTART</code> -&gt; <code>READ (Status)</code>.</li> <li>Cela permet effectivement de r\u00e9cup\u00e9rer le statut du bo\u00eetier esclave (Acquittement, mais potentiellement aussi des \u00e9tats inputs si impl\u00e9ment\u00e9) dans la m\u00eame transaction.</li> <li>Le firmware v\u00e9rifie ce retour (<code>l_uc_ReponseRecue</code>) pour valider la bonne ex\u00e9cution.</li> </ul> </li> <li> <p>Interaction avec le Serveur :</p> <ul> <li>NON, <code>uc_TRAME_BA_ACTIONS</code> n'appelle jamais directement le serveur Essensys.</li> <li>L'architecture est d\u00e9coupl\u00e9e :<ol> <li>La t\u00e2che Ethernet (<code>ETH_TASK</code>) re\u00e7oit des ordres du serveur et met \u00e0 jour la m\u00e9moire partag\u00e9e (<code>Tb_Echange</code>).</li> <li>La t\u00e2che Boitiers (<code>BA_TASK</code>) d\u00e9tecte ce changement en m\u00e9moire et d\u00e9clenche <code>uc_TRAME_BA_ACTIONS</code>.</li> <li>Inversement, si un statut change sur un BA, il est remont\u00e9 en m\u00e9moire, et la t\u00e2che Ethernet l'enverra au serveur lors du prochain cycle de synchronisation (<code>sc_PostInformationServer</code>).</li> </ol> </li> </ul> </li> </ul>"},{"location":"firmware/#diagrammes-de-sequence","title":"Diagrammes de S\u00e9quence","text":"<p>Architecture Globale</p> <pre><code>graph TD\n    Server[Serveur Essensys] -- HTTP GET/POST --&gt; ETH[T\u00e2che Ethernet SC944D]\n    ETH -- Ecrit/Lit --&gt; Mem[Tb_Echange (M\u00e9moire Partag\u00e9e)]\n    BA[T\u00e2che Boitiers SC944D] -- Lit/Ecrit --&gt; Mem\n    BA -- I2C (Trame Actions) --&gt; Slave[Carte Fille SC94x]</code></pre> <p>Flux de Donn\u00e9es : Serveur vers Action Hardware</p> <pre><code>sequenceDiagram\n    participant Server as Serveur\n    participant ETH as T\u00e2che Ethernet\n    participant Mem as Table Echange\n    participant BA as T\u00e2che Bo\u00eetiers\n    participant Slave as Carte Fille (I2C)\n\n    Note over Server, Slave: 1. Le Serveur envoie une commande (ex: Allumer Lumi\u00e8re)\n    Server-&gt;&gt;ETH: GET /api/myactions (JSON)\n    ETH-&gt;&gt;ETH: Parsing JSON\n    ETH-&gt;&gt;Mem: Ecriture Action (Tb_Echange[IND] = 1)\n\n    Note over Mem, Slave: 2. Le SC944D traite la commande en local\n    loop Cycle T\u00e2che Bo\u00eetiers\n        BA-&gt;&gt;Mem: Lecture Etat\n        BA-&gt;&gt;BA: Comparaison (Diff\u00e9rence d\u00e9tect\u00e9e !)\n        BA-&gt;&gt;Slave: I2C Write `uc_TRAME_BA_ACTIONS`\n        Slave-&gt;&gt;BA: I2C Ack + Status\n        BA-&gt;&gt;BA: Mise \u00e0 jour statut interne\n    end\n\n    Note over Server, Slave: 3. Retour d'\u00e9tat vers le Serveur\n    ETH-&gt;&gt;Server: POST /api/done (Acquittement)</code></pre>"},{"location":"firmware/#format-de-la-trame-physique","title":"Format de la Trame Physique","text":"Octet Description 0 Code Commande (<code>uc_TRAME_BA_ACTIONS</code>) 1 Donn\u00e9es (Bitmask des relais/actions) 2 CRC (Poids faible) 3 CRC (Poids fort) <ul> <li>For\u00e7age :<ul> <li>Si un message prioritaire arrive (via Message Queue), une trame <code>uc_TRAME_BA_FORCAGE_SORTIES</code> est envoy\u00e9e imm\u00e9diatement (ex: coupure d'urgence).</li> </ul> </li> </ul>"},{"location":"firmware/#3-connexion-serveur-et-mise-a-jour-firmware","title":"3. Connexion Serveur et Mise \u00e0 Jour Firmware","text":"<p>La t\u00e2che Ethernet (<code>Ethernet/www.c</code>) g\u00e8re la machine d'\u00e9tat r\u00e9seau :</p> <ol> <li>Connexion R\u00e9seau : V\u00e9rification lien physique, obtention IP (DHCP ou Fixe), R\u00e9solution DNS de <code>mon.essensys.fr</code>.</li> <li>Dialogue Serveur (<code>sc_DialogueAvecServeur</code>) :<ul> <li>GET /api/serverinfos (<code>sc_GetInformationServer</code>) :<ul> <li>R\u00e9cup\u00e8re l'\u00e9tat de la connexion (<code>isconnected</code>), la pr\u00e9sence d'une nouvelle version (<code>newversion</code>).</li> <li>Demande d'informations (<code>infos</code>): Le serveur fournit une liste d'ID (Table Echange) dont il souhaite conna\u00eetre la valeur actuelle.<ul> <li>Capacit\u00e9 : Le serveur peut demander jusqu'\u00e0 30 ID simultan\u00e9ment (<code>uc_NB_MAX_INFOS_DEMANDEES_PAR_SERVEUR</code>).</li> <li>Usage : Cela permet au serveur de r\u00e9cup\u00e9rer l'\u00e9tat de n'importe quelle variable du syst\u00e8me (ex: <code>Variateurs_PDV_Conf</code> pour l'\u00e9clairage, <code>Scenario</code>, <code>Temp\u00e9ratures</code>, etc.).</li> <li>Lumi\u00e8res : Le serveur peut donc savoir quelles lumi\u00e8res sont allum\u00e9es ou \u00e9teintes en lisant les registres correspondants. Attention, il s'agit de l'\u00e9tat \"command\u00e9\" (m\u00e9moire du SC944D) et non d'un retour d'\u00e9tat physique du relais (pas de feedback mat\u00e9riel d'intensit\u00e9 dans le protocole I2C actuel).</li> </ul> </li> </ul> </li> <li>POST /api/mystatus (<code>sc_PostInformationServer</code>) : Envoie les valeurs demand\u00e9es pr\u00e9c\u00e9demment au format JSON <code>{k:ID, v:Valeur}</code>.</li> <li>GET /api/myactions (<code>sc_ActionManagment</code>) : R\u00e9cup\u00e8re les actions \u00e0 ex\u00e9cuter (ex: pilotage relais, <code>Scenario_Allumer_PDV_LSB</code>).</li> </ul> </li> <li>T\u00e9l\u00e9chargement Firmware (<code>sc_Download</code>) :<ul> <li>Si <code>newversion</code> != 0 dans la r\u00e9ponse serveur :<ul> <li>Le syst\u00e8me passe en mode \"Download\" (suspend I2C).</li> <li>T\u00e9l\u00e9charge le binaire S19 via HTTP.</li> <li>Le stocke en Flash (zone r\u00e9serv\u00e9e).</li> <li>V\u00e9rifie le CRC.</li> <li>Sauvegarde la <code>TableEchange</code> en Flash.</li> <li>Reboot (<code>vd_MCF52259_REBOOT</code>) pour appliquer la mise \u00e0 jour (Bootloader).</li> </ul> </li> </ul> </li> </ol>"},{"location":"firmware/#4-mise-a-jour-table-de-reference-et-statuts","title":"4. Mise \u00e0 jour Table de R\u00e9f\u00e9rence et Statuts","text":"<p>Le syst\u00e8me repose sur une table centrale <code>Tb_Echange</code> (<code>TableEchange.h</code>) qui contient tout l'\u00e9tat du syst\u00e8me.</p> <ul> <li> <p>R\u00e9ception des Actions (Server -&gt; SC944D) :</p> <ul> <li>La fonction <code>sc_TraiterActions</code> re\u00e7oit un JSON du serveur (GUID + Param\u00e8tres).</li> <li>Elle parse les paires <code>(Index, Valeur)</code>.</li> <li>Elle met \u00e0 jour <code>Tb_Echange</code> via <code>uc_TableEchange_Ecrit_Data(Index, Valeur)</code>.</li> <li>Cas particulier : Les sc\u00e9narios sont appliqu\u00e9s en dernier pour garantir que tous les param\u00e8tres sont pr\u00eats.</li> <li>Acquittement : Envoi d'un <code>POST /api/done/{GUID}</code> au serveur.</li> </ul> </li> <li> <p>Envoi des Statuts (SC944D -&gt; Server) :</p> <ul> <li>Lors du <code>GET /api/serverinfos</code>, le serveur fournit une liste d'ID de donn\u00e9es qu'il souhaite conna\u00eetre (<code>infos: [10, 24, ...]</code>).</li> <li>Le SC944D r\u00e9pond via <code>POST /api/mystatus</code> en lisant ces ID dans <code>Tb_Echange</code> (<code>uc_TableEchange_Lit_Data</code>) et en construisant un JSON <code>{k:ID, v:Valeur}</code>.</li> </ul> </li> </ul>"},{"location":"firmware/#mapping-memoire","title":"Mapping M\u00e9moire","text":"<p>Le projet utilise : *   Flash Interne : Code et constantes. *   MRAM/EEPROM : Sauvegarde des param\u00e8tres (Mac Address, Soft Params, etc.).</p>"},{"location":"hardware/","title":"\ud83d\udd0c Hardware","text":"<p>Cette section d\u00e9taille la conception mat\u00e9rielle du module SC944D.</p>"},{"location":"hardware/#specifications-techniques","title":"Sp\u00e9cifications Techniques","text":"<ul> <li>Tension d'alimentation : [\u00c0 compl\u00e9ter]</li> <li>Consommation : [\u00c0 compl\u00e9ter]</li> <li>Dimensions : [\u00c0 compl\u00e9ter]</li> </ul>"},{"location":"hardware/#composants-principaux","title":"Composants Principaux","text":"<ul> <li>MCU : [R\u00e9f\u00e9rence]</li> <li>Connecteurs :<ul> <li>[Connecteur 1]</li> <li>[Connecteur 2]</li> </ul> </li> </ul>"},{"location":"hardware/#routage-pcb","title":"Routage (PCB)","text":"<p>Le PCB est con\u00e7u en [Nombre] couches.</p>"},{"location":"i2c/","title":"\ud83d\udce1 Protocole I2C (Inter-Board)","text":"<p>Cette page d\u00e9taille le protocole de communication entre la carte principale SC944D (Ma\u00eetre) et les cartes filles auxiliaires SC940, SC941, SC942, SC943 (Esclaves).</p>"},{"location":"i2c/#architecture-physique","title":"Architecture Physique","text":"<ul> <li>Bus : I2C</li> <li>Vitesse : Standard (100 kHz) ou Fast Mode (selon config).</li> <li>Ma\u00eetre : SC944D (<code>BA_TASK</code>).</li> <li>Esclaves : Modules d\u00e9port\u00e9s, adress\u00e9s par configuration mat\u00e9rielle (Adresses 0 \u00e0 <code>uc_NB_BOITIER_AUXILIAIRE - 1</code>).</li> </ul>"},{"location":"i2c/#strategie-de-communication","title":"Strat\u00e9gie de Communication","text":""},{"location":"i2c/#algo-maitre-sc944d-send-on-change","title":"Algo Ma\u00eetre (SC944D) : \"Send on Change\"","text":"<p>Le SC944D n'envoie pas les commandes en continu pour ne pas saturer le bus. Il utilise une strat\u00e9gie d'envoi sur changement.</p> <pre><code>graph TD\n    Start((Start Loop)) --&gt; CheckChange{Nouvelle Consigne ?}\n    CheckChange -- OUI --&gt; PrepareFrame[Pr\u00e9parer Trame ACTIONS]\n    CheckChange -- NON --&gt; CheckForce{For\u00e7age ?}\n    CheckForce -- OUI --&gt; SendForce[Envoyer Trame FORCAGE]\n    CheckForce -- NON --&gt; Next[Bo\u00eetier Suivant]\n    PrepareFrame --&gt; SendI2C[Appel sl_fct_write_polled]\n    SendForce --&gt; SendI2C\n    SendI2C --&gt; VerifyAck{ACK Re\u00e7u ?}\n    VerifyAck -- OUI --&gt; UpdateStatus[Mise \u00e0 jour Tb_Actions_Ack]\n    VerifyAck -- NON --&gt; Retry[Incr\u00e9menter Compteur Erreur]\n    UpdateStatus --&gt; Next\n    Retry --&gt; Next</code></pre> <ol> <li>Boucle de Surveillance : La t\u00e2che <code>BA_TASK</code> tourne en permanence (toutes les 50ms).</li> <li>Comparaison : Pour chaque bo\u00eetier esclave, elle compare :<ul> <li>L'\u00e9tat d\u00e9sir\u00e9 (calcul\u00e9 par les sc\u00e9narios ou commandes serveur dans <code>Tb_Echange</code>).</li> <li>L'\u00e9tat derni\u00e8rement acquitt\u00e9 (m\u00e9moris\u00e9 localement dans <code>Tb_Actions_Ack_BA</code>).</li> </ul> </li> <li>D\u00e9cision :<ul> <li>Si Diff\u00e9rent : Une trame <code>uc_TRAME_BA_ACTIONS</code> est g\u00e9n\u00e9r\u00e9e avec toutes les actions du bo\u00eetier (sous forme d'octets/masques).</li> <li>Si Identique : Rien n'est envoy\u00e9 (silence sur le bus).</li> <li>Exception : Si un mode \"Secouru\" ou \"Reset\" est activ\u00e9, une trame est forc\u00e9e.</li> </ul> </li> </ol>"},{"location":"i2c/#algo-esclave-cartes-filles","title":"Algo Esclave (Cartes Filles)","text":"<p>Les cartes filles sont passives. Elles attendent les ordres I2C, appliquent les \u00e9tats aux relais/sorties, et r\u00e9pondent \u00e0 la requ\u00eate de lecture du Ma\u00eetre pour acquitter.</p>"},{"location":"i2c/#format-des-trames","title":"Format des Trames","text":"<p>Le protocole utilise un \u00e9change atomique \u00c9criture puis Lecture (Repeated Start).</p> <pre><code>sequenceDiagram\n    participant Master as SC944D\n    participant Slave as Carte Fille\n\n    Master-&gt;&gt;Slave: I2C START\n    Master-&gt;&gt;Slave: ADDR + WRITE\n    Master-&gt;&gt;Slave: CMD (1 Octet)\n    Master-&gt;&gt;Slave: DATA (n Octets)\n    Master-&gt;&gt;Slave: CRC (2 Octets)\n\n    Master-&gt;&gt;Slave: I2C REPEATED START\n    Master-&gt;&gt;Slave: ADDR + READ\n\n    Slave--&gt;&gt;Master: ECHO CMD (1 Octet)\n    Slave--&gt;&gt;Master: ECHO CRC (2 Octets)\n    Slave--&gt;&gt;Master: RESPONSE CRC (2 Octets)\n\n    Master-&gt;&gt;Slave: I2C STOP</code></pre>"},{"location":"i2c/#1-ecriture-master-slave","title":"1. \u00c9criture (Master -&gt; Slave)","text":"<p>Le Ma\u00eetre envoie la commande et les nouvelles consignes.</p> Octet Contenu Description 0 <code>CMD</code> Code commande (ex: <code>uc_TRAME_BA_ACTIONS</code> = 1) 1 <code>DATA</code> Donn\u00e9es (Masque des relais, valeurs, etc.) 2 <code>CRC_LSB</code> CRC-16 (Poids faible) calcul\u00e9 sur CMD+DATA 3 <code>CRC_MSB</code> CRC-16 (Poids fort)"},{"location":"i2c/#2-lecture-master-slave","title":"2. Lecture (Master &lt;- Slave)","text":"<p>Imm\u00e9diatement apr\u00e8s l'\u00e9criture, le Ma\u00eetre lit 5 octets pour v\u00e9rifier que l'Esclave a bien re\u00e7u la commande. Important : Cette lecture sert d'acquittement protocolaire, elle ne remonte PAS l'\u00e9tat physique des entr\u00e9es/sorties (pas de lecture de capteur).</p> Octet Contenu Description 0 <code>ECHO_CMD</code> L'esclave renvoie le code commande re\u00e7u (<code>CMD</code>) 1 <code>ECHO_CRC_LSB</code> L'esclave renvoie le CRC qu'il a re\u00e7u (pour v\u00e9rification int\u00e9grit\u00e9) 2 <code>ECHO_CRC_MSB</code> L'esclave renvoie le CRC qu'il a re\u00e7u 3 <code>RESP_CRC_LSB</code> CRC-16 de la r\u00e9ponse (calcul\u00e9 sur octets 0-2) 4 <code>RESP_CRC_MSB</code> CRC-16 de la r\u00e9ponse <p>Le Ma\u00eetre v\u00e9rifie : 1.  Que <code>ECHO_CMD</code> correspond \u00e0 la commande envoy\u00e9e. 2.  Que <code>ECHO_CRC</code> correspond au CRC envoy\u00e9 (preuve que l'esclave a re\u00e7u les donn\u00e9es sans corruption). 3.  Que <code>RESP_CRC</code> est valide (preuve que la r\u00e9ponse n'est pas corrompue).</p>"},{"location":"i2c/#types-de-trames","title":"Types de Trames","text":""},{"location":"i2c/#uc_trame_ba_actions-0x01","title":"<code>uc_TRAME_BA_ACTIONS</code> (0x01)","text":"<ul> <li>Usage : Mise \u00e0 jour standard des sorties (Lumi\u00e8res, Volets).</li> <li>Contenu : Un octet concat\u00e9nant les flags d'activation.</li> </ul>"},{"location":"i2c/#uc_trame_ba_forcage_sorties-0x02","title":"<code>uc_TRAME_BA_FORCAGE_SORTIES</code> (0x02)","text":"<ul> <li>Usage : Actions prioritaires ou massives.</li> <li>D\u00e9clenchement : Via Message Queue (non cyclique).</li> </ul>"},{"location":"i2c/#recuperation-des-valeurs","title":"R\u00e9cup\u00e9ration des Valeurs","text":"<p>\u26a0\ufe0f Point d'attention : Le syst\u00e8me est en \"Boucle Ouverte\" au niveau I2C. *   Le SC944D sait ce qu'il a demand\u00e9 (m\u00e9moire <code>Tb_Echange</code>). *   Il sait que le message est bien arriv\u00e9 (Acquittement CRC). *   Il ne lit pas l'\u00e9tat r\u00e9el du relais (pas de retour d'information \"Lumi\u00e8re r\u00e9ellement allum\u00e9e\" si le relais est coll\u00e9 ou l'ampoule grill\u00e9e).</p> <p>C'est pourquoi, lorsque le Serveur demande l'\u00e9tat des lumi\u00e8res, le SC944D renvoie la valeur de sa m\u00e9moire (l'\u00e9tat command\u00e9).</p>"},{"location":"i2c/#faq-technique","title":"\u2753 FAQ Technique","text":""},{"location":"i2c/#peut-on-forcer-la-lecture-de-letat-dun-relais","title":"Peut-on forcer la lecture de l'\u00e9tat d'un relais ?","text":"<p>Analyse du code (<code>ba_i2c.c</code>) : *   NON, il n'existe pas de fonction ou de commande I2C d\u00e9di\u00e9e \u00e0 la \"Lecture Seule\" ou \"Lecture d'Etat Physique\" dans le protocole actuel. *   La seule lecture (<code>fread</code>) est effectu\u00e9e syst\u00e9matiquement apr\u00e8s une \u00e9criture (<code>write</code>) dans la fonction <code>sl_fct_write_polled</code>. *   Cette lecture r\u00e9cup\u00e8re des donn\u00e9es de protocole (Echo, CRC) et non des donn\u00e9es fonctionnelles (Etat relais, Intensit\u00e9 courant, etc.).</p> <p>Conclusion : Pour savoir si une lumi\u00e8re est allum\u00e9e, le SC944D se fie uniquement au fait qu'il a envoy\u00e9 l'ordre et re\u00e7u un acquittement valide. Il n'y a pas de double v\u00e9rification mat\u00e9rielle via le bus I2C.</p>"}]}